{"version":3,"file":"sourcemap-8ed5be4f.js","sources":["../../src/csm/jsonpath.ts","../../src/csm/sourcemap.ts"],"sourcesContent":["import type { PathSegment } from './types'\n\nconst ESCAPE: Record<string, string> = {\n  '\\f': '\\\\f',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t',\n  \"'\": \"\\\\'\",\n  '\\\\': '\\\\\\\\',\n}\n\nconst UNESCAPE: Record<string, string> = {\n  '\\\\f': '\\f',\n  '\\\\n': '\\n',\n  '\\\\r': '\\r',\n  '\\\\t': '\\t',\n  \"\\\\'\": \"'\",\n  '\\\\\\\\': '\\\\',\n}\n\n/** @internal */\nexport function normalisedJsonPath(path: PathSegment[]): string {\n  return `$${path\n    .map((key) => {\n      if (typeof key === 'string') {\n        const escapedKey = key.replace(/[\\f\\n\\r\\t'\\\\]/g, (match) => {\n          return ESCAPE[match]\n        })\n        return `['${escapedKey}']`\n      }\n\n      return `[${key}]`\n    })\n    .join('')}`\n}\n\n/** @internal */\nexport function parseNormalisedJsonPath(path: string): PathSegment[] {\n  const parsed: PathSegment[] = []\n\n  const parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]/g\n  let match: RegExpExecArray | null\n\n  while ((match = parseRe.exec(path)) !== null) {\n    if (match[1] !== undefined) {\n      const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, (m) => {\n        return UNESCAPE[m]\n      })\n\n      parsed.push(key)\n      continue\n    }\n\n    if (match[2] !== undefined) {\n      parsed.push(parseInt(match[2], 10))\n      continue\n    }\n  }\n\n  return parsed\n}\n","/* eslint-disable no-nested-ternary */\nimport type {\n  ContentSourceMap,\n  ContentSourceMapDocuments,\n  ContentSourceMapMapping,\n} from '@sanity/client'\n\nimport { normalisedJsonPath, parseNormalisedJsonPath } from './jsonpath'\nimport type { Logger, PathSegment } from './types'\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null\n}\n\nfunction isArray(value: unknown): value is Array<unknown> {\n  return value !== null && Array.isArray(value)\n}\n\n/** @alpha */\nexport type Encoder<E> = (\n  value: string,\n  sourceDocument: ContentSourceMapDocuments[number],\n  path: PathSegment[],\n) => E\n\n/** @alpha */\nexport function encode<R, E>(\n  result: R,\n  csm: ContentSourceMap,\n  encoder: Encoder<E>,\n): R {\n  return encodeIntoResult(result, csm, encoder) as R\n}\n\n/** @alpha */\nexport function encodeIntoResult<R>(\n  result: R,\n  csm: ContentSourceMap,\n  encoder: Encoder<unknown>,\n): ReturnType<Encoder<unknown>> {\n  return walkMap(result, (value, path) => {\n    // Only map strings, we could extend this in the future to support other types like integers...\n    if (typeof value !== 'string') {\n      return value\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const resolveMappingResult = resolveMapping(path, csm)\n    if (!resolveMappingResult) {\n      return value\n    }\n\n    const [mapping, , pathSuffix] = resolveMappingResult\n    if (mapping.type !== 'value') {\n      return value\n    }\n\n    if (mapping.source.type !== 'documentValue') {\n      return value\n    }\n\n    const sourceDocument =\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      csm.documents[mapping.source.document!]\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const sourcePath = csm.paths[mapping.source.path]\n\n    return encoder(\n      value,\n      sourceDocument,\n      parseNormalisedJsonPath(sourcePath + pathSuffix),\n    )\n  })\n}\n\nexport type WalkMapFn = (value: unknown, path: PathSegment[]) => unknown\n\n// generic way to walk a nested object or array and apply a mapping function to each value\nexport function walkMap(\n  value: unknown,\n  mappingFn: WalkMapFn,\n  path: PathSegment[] = [],\n): unknown {\n  if (isArray(value)) {\n    return value.map((v, idx) => walkMap(v, mappingFn, path.concat(idx)))\n  }\n\n  if (isRecord(value)) {\n    return Object.fromEntries(\n      Object.entries(value).map(([k, v]) => [\n        k,\n        walkMap(v, mappingFn, path.concat(k)),\n      ]),\n    )\n  }\n\n  return mappingFn(value, path)\n}\n\nexport function resolveMapping(\n  resultPath: PathSegment[],\n  csm: ContentSourceMap,\n  logger?: Logger,\n): [ContentSourceMapMapping, string, string] | undefined {\n  const resultJsonPath = normalisedJsonPath(resultPath)\n\n  if (!csm.mappings) {\n    logger?.error?.('Missing mappings', {\n      resultSourceMap: csm,\n    })\n    return undefined\n  }\n\n  if (csm.mappings[resultJsonPath] !== undefined) {\n    return [csm.mappings[resultJsonPath], resultJsonPath, '']\n  }\n\n  const mappings = Object.entries(csm.mappings)\n    .filter(([key]) => resultJsonPath.startsWith(key))\n    .sort(([key1], [key2]) => key2.length - key1.length)\n\n  if (mappings.length == 0) {\n    return undefined\n  }\n\n  const [matchedPath, mapping] = mappings[0]\n  const pathSuffix = resultJsonPath.substring(matchedPath.length)\n  return [mapping, matchedPath, pathSuffix]\n}\n"],"names":["ESCAPE","UNESCAPE","normalisedJsonPath","path","concat","map","key","escapedKey","replace","match","join","parseNormalisedJsonPath","parsed","parseRe","exec","m","push","parseInt","isRecord","value","isArray","Array","encode","result","csm","encoder","encodeIntoResult","walkMap","resolveMappingResult","resolveMapping","mapping","pathSuffix","type","source","sourceDocument","documents","document","sourcePath","paths","mappingFn","arguments","length","undefined","v","idx","Object","fromEntries","entries","_ref","k","resultPath","logger","_a","resultJsonPath","mappings","error","resultSourceMap","filter","_ref2","startsWith","sort","_ref3","_ref4","key1","key2","matchedPath","substring"],"mappings":"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"}