'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var client = require('@sanity/client');
var isPlainObject = require('lodash.isplainobject');
var csm = require('./csm.cjs');
function _interopDefaultCompat(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    default: e
  };
}
var isPlainObject__default = /*#__PURE__*/_interopDefaultCompat(isPlainObject);
function transcodeResponse(_ref) {
  let {
    studioUrl,
    encodeSourceMapAtPath,
    logger
  } = _ref;
  const transcoder = csm.createTranscoder({
    studioUrl,
    encodeSourceMapAtPath,
    logger
  });
  return {
    onResponse: response => {
      var _a, _b, _c, _d, _e, _f, _g;
      if (!isBodyResponse(response)) {
        return response;
      }
      if (Array.isArray(response.body) || typeof response.body === "string" || isPlainObject__default.default(response.body)) {
        if (!isContentSourceMapBody(response.body)) {
          if (logger && isResultBody(response.body)) {
            (_a = logger == null ? void 0 : logger.error) == null ? void 0 : _a.call(logger, "[@sanity/preview-kit]: Missing Content Source Map from response body", response.body);
          }
          return response;
        }
        const transcoderResult = transcoder(response.body.result, response.body.resultSourceMap);
        if (logger) {
          const isSkipping = transcoderResult.report.skipped.length;
          const isEncoding = transcoderResult.report.encoded.length;
          if (isSkipping || isEncoding) {
            (_b = (logger == null ? void 0 : logger.groupCollapsed) || logger.log) == null ? void 0 : _b("[@sanity/preview-kit]: Stega encoding source map into result");
            (_c = logger.log) == null ? void 0 : _c.call(logger, "[@sanity/preview-kit]: Paths encoded: ".concat(transcoderResult.report.encoded.length, ", skipped: ").concat(transcoderResult.report.skipped.length));
          }
          if (transcoderResult.report.encoded.length > 0) {
            (_d = logger == null ? void 0 : logger.log) == null ? void 0 : _d.call(logger, "[@sanity/preview-kit]: Table of encoded paths");
            (_e = (logger == null ? void 0 : logger.table) || logger.log) == null ? void 0 : _e(transcoderResult.report.encoded);
          }
          if (transcoderResult.report.skipped.length > 0) {
            const skipped = /* @__PURE__ */new Set();
            for (const {
              path
            } of transcoderResult.report.skipped) {
              skipped.add(path.replace(/\[\d+\]/g, "[]"));
            }
            (_f = logger == null ? void 0 : logger.log) == null ? void 0 : _f.call(logger, "[@sanity/preview-kit]: List of skipped paths", [...skipped.values()]);
          }
          if (isSkipping || isEncoding) {
            (_g = logger == null ? void 0 : logger.groupEnd) == null ? void 0 : _g.call(logger);
          }
        }
        const body = {
          ...response.body,
          result: transcoderResult.result
        };
        return {
          ...response,
          body
        };
      }
      return response;
    }
  };
}
function createHttpRequest(_ref2) {
  let {
    studioUrl,
    encodeSourceMapAtPath,
    logger
  } = _ref2;
  const superRequester = client.requester.clone();
  superRequester.use(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any -- support the improved get-it typings
  transcodeResponse({
    studioUrl,
    encodeSourceMapAtPath,
    logger
  }));
  function httpRequest(options) {
    let requester = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : superRequester;
    return requester({
      maxRedirects: 0,
      ...options
    });
  }
  httpRequest.defaultRequester = superRequester;
  return httpRequest;
}
function isBodyResponse(response) {
  return typeof response === "object" && response !== null;
}
function isResultBody(body) {
  return typeof body === "object" && body !== null && "result" in body;
}
function isContentSourceMapBody(body) {
  return typeof body === "object" && body !== null && "resultSourceMap" in body;
}
const createClient = config => {
  var _a, _b;
  const {
    encodeSourceMap = detectEnableSourceMap(),
    encodeSourceMapAtPath,
    studioUrl = detectStudioUrl(),
    logger,
    ...options
  } = config;
  let shouldEncodeSourceMap = encodeSourceMap === true;
  if (encodeSourceMap === "auto") {
    shouldEncodeSourceMap = isVercelPreviewEnvironment();
  }
  if (typeof encodeSourceMap === "string" && encodeSourceMap !== "auto") {
    throw new Error("Invalid value for encodeSourceMap: ".concat(encodeSourceMap, ". Did you mean 'auto'?"));
  }
  try {
    if (shouldEncodeSourceMap && config.resultSourceMap !== false) {
      if (!studioUrl) {
        (_a = logger == null ? void 0 : logger.error) == null ? void 0 : _a.call(logger, "[@sanity/preview-kit]: Content source map enabled client is enabled, but no studioUrl is provided. Falling back to @sanity/client");
        return client.createClient(options);
      }
      (_b = logger == null ? void 0 : logger.debug) == null ? void 0 : _b.call(logger, "[@sanity/preview-kit]: Creating source map enabled client");
      const httpRequest = createHttpRequest({
        encodeSourceMapAtPath,
        studioUrl,
        logger
      });
      return new client.SanityClient(httpRequest, {
        ...options,
        // Source maps by Content Lake are required in order to know where to insert the encoded source maps into strings
        resultSourceMap: true
      });
    }
  } catch (err) {
    console.error("[@sanity/preview-kit]: Error creating client", err, "falling back to non-embedded sourcemap mode");
  }
  return client.createClient(options);
};
function isVercelPreviewEnvironment() {
  try {
    return undefined.VERCEL_ENV === "preview";
  } catch {}
  try {
    return process.env.VERCEL_ENV === "preview";
  } catch {}
  return false;
}
function detectEnableSourceMap() {
  try {
    return undefined.SANITY_SOURCE_MAP === "true" || "auto";
  } catch {}
  try {
    return process.env.SANITY_SOURCE_MAP === "true" || "auto";
  } catch {}
  return "auto";
}
function detectStudioUrl() {
  try {
    return undefined.SANITY_STUDIO_URL;
  } catch {}
  try {
    return process.env.SANITY_STUDIO_URL;
  } catch {}
}
function mapToEditLinks(response, studioUrl) {
  return csm.mapToEditLinks(response.result, response.resultSourceMap, studioUrl);
}
exports.createClient = createClient;
exports.mapToEditLinks = mapToEditLinks;
//# sourceMappingURL=client.cjs.map
